#!/usr/bin/env python

import rospy
import math
import sys
import os

import numpy as np
import cv2 as cv
import matplotlib.pylab as plt
import message_filters as MF

from sensor_msgs.msg import Import
from cv_bridge import CvBride

def decode_ros_image(img_msg, encoding = 'bgr8'):
    bridge = CvBridge()
    cv_img = None
    try:
        cv_img = bridge.imgmsg_to_cv2(img_msg, encoding)
    except Exception as e:
        print e
    return cv_img


def depth_filling_and_interpolation(im_depth):
    if image is None:
        rospy.logerr("[::depth_filling_and_interpolation]: EMPTY")
        return False

    scale_factor = 0.2
    depth_reduce = cv.resize(im_depth, fx = scale_factor, fy = scale_factor)


def callback(image_msg, depth_msg):
    im_rgb = decode_ros_image(image_msg)
    im_dep = decode_ros_image(depth_msg, '32FC1')

    
    
    
    cv.imshow("image", im_rgb)
    cv.waitKey(3)
    
    
def on_init():
    topic_rgb = '/kinect2/sd/image_color_rect'
    topic_depth = '/kinect2/sd/image_depth_rect'
    
    rgb_sub = MF.Subscriber(topic_rgb, Image)
    depth_sub = MF.Subscriber(topic_depth, Image)

    ats = MF.ApproximateTimeSynchronizer([rgb_sub, depth_sub], 10, 10)
    ats.registerCallback(callback)
    
def main(argv):
    rospy.init_node('rgbd_grid', anonymous = True)
    on_init()
    rospy.spin()

if __name__ == '__main__':
    main(sys.argv)
